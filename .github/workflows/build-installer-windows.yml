name: Build and Package Windows Installer

on:
  push:
    branches: [ "main" ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

env:
  # variáveis globais (herdadas por jobs/steps)
  VCPKG_DEFAULT_TRIPLET: x64-windows
  BUILD_DIR: build
  VS_GENERATOR: "Visual Studio 17 2022"
  VS_ARCH: x64
  # caminho padrão usado pelo Chocolatey para executáveis
  CHOCO_BIN: "C:/ProgramData/chocolatey/bin"

jobs:
  build-windows-installer:
    runs-on: windows-latest
    env:
      # Variáveis específicas para este job ou que sobrescrevem as globais.
      # A sintaxe de referência a si mesma (ex: BUILD_DIR: ${{ env.BUILD_DIR }}) foi removida, pois é inválida.
      # As variáveis globais já estão disponíveis aqui por padrão.
      VCPKG_ROOT: ${{ github.workspace }}/vcpkg
      MAKENSIS_DEFAULT: "${{ env.CHOCO_BIN }}/makensis.exe"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Show quick context
        shell: pwsh
        run: |
          Write-Host "Workspace: $env:GITHUB_WORKSPACE"
          Write-Host "VCPKG_ROOT: $env:VCPKG_ROOT"
          Write-Host "BUILD_DIR: $env:BUILD_DIR"
          Write-Host "VS_GENERATOR: $env:VS_GENERATOR"
          Write-Host "VS_ARCH: $env:VS_ARCH"

      - name: Ensure Chocolatey packages (ninja, nsis)
        shell: pwsh
        run: |
          choco feature enable -n=allowGlobalConfirmation | Out-Null
          choco install ninja --yes --no-progress
          choco install nsis --yes --no-progress
          choco list --local-only

      - name: Ensure CMake (uses action for version)
        uses: jwlawson/actions-setup-cmake@v1.14
        with:
          cmake-version: '3.29.3'

      - name: Ensure Ninja on PATH (verify)
        shell: pwsh
        run: |
          Get-Command ninja -ErrorAction SilentlyContinue || Write-Host "ninja not found"
          Get-Command makensis -ErrorAction SilentlyContinue || Write-Host "makensis not found yet"
          where.exe makensis || echo "where.exe didn't find makensis"

      - name: Cache vcpkg downloads & installed (speeds up repeated runs)
        uses: actions/cache@v4
        with:
          path: |
            ${{ env.VCPKG_ROOT }}/downloads
            ${{ env.VCPKG_ROOT }}/installed
            ${{ env.VCPKG_ROOT }}/buildtrees
          # chave mais robusta para cache
          key: vcpkg-cache-${{ runner.os }}-${{ hashFiles('**/vcpkg.json') }}
          restore-keys: |
            vcpkg-cache-${{ runner.os }}-

      - name: Install vcpkg and required libs
        shell: pwsh
        run: |
          if (-not (Test-Path $env:VCPKG_ROOT)) {
            git clone --depth 1 https://github.com/microsoft/vcpkg.git $env:VCPKG_ROOT
          } else {
            Write-Host "vcpkg already exists at $env:VCPKG_ROOT"
          }
          Push-Location $env:VCPKG_ROOT
          # desabilita telemetria para runs CI
          .\bootstrap-vcpkg.bat -disableMetrics
          .\vcpkg.exe install curl lua nlohmann-json --triplet $env:VCPKG_DEFAULT_TRIPLET
          Pop-Location

      - name: Setup Rust toolchain (only installer, no cache actions)
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable

      - name: Verify important files (debug)
        shell: pwsh
        run: |
          Write-Host "Listing root files:"
          Get-ChildItem -Force -File -Name
          Write-Host "Listing installer folder if exists:"
          if (Test-Path installer/windows) { Get-ChildItem installer/windows -Recurse -File -Name } else { Write-Host "installer/windows not found" }

      - name: Configure CMake (MSVC, Visual Studio generator)
        shell: pwsh
        run: |
          # Determina onde o makensis está
          $makensis = (Get-Command makensis -ErrorAction SilentlyContinue).Source
          if (-not $makensis) {
            # fallback para o local esperado
            $makensis = $env:MAKENSIS_DEFAULT
            Write-Host "makensis not found in PATH, will try $makensis"
          } else {
            Write-Host "Found makensis at: $makensis"
          }

          # Diretório do NSIS
          $nsis_dir = Split-Path $makensis

          # Comando de configuração do CMake
          cmake -S . -B $env:BUILD_DIR -G "$env:VS_GENERATOR" -A $env:VS_ARCH `
            -DCMAKE_TOOLCHAIN_FILE="$env:VCPKG_ROOT\scripts\buildsystems\vcpkg.cmake" `
            -DCMAKE_PREFIX_PATH="$env:VCPKG_ROOT\installed\$env:VCPKG_DEFAULT_TRIPLET\share" `
            -DLua_FOUND=TRUE `
            -DLUA_INCLUDE_DIR="$env:VCPKG_ROOT\installed\$env:VCPKG_DEFAULT_TRIPLET\include" `
            -DLUA_LIBRARY="$env:VCPKG_ROOT\installed\$env:VCPKG_DEFAULT_TRIPLET\lib\lua.lib" `
            -DLUA_LIBRARIES="$env:VCPKG_ROOT\installed\$env:VCPKG_DEFAULT_TRIPLET\lib\lua.lib" `
            -DMAKENSIS_EXECUTABLE="$makensis" `
            -DNSIS_MAKENSIS_EXECUTABLE="$makensis" `
            -DNSIS_DIR="$nsis_dir" `
            -DCMAKE_BUILD_TYPE=Release

          Write-Host "CMake configure return code: $LASTEXITCODE"
          Write-Host "Show first 200 lines of $env:BUILD_DIR/CMakeFiles/CMakeOutput.log if present"
          if (Test-Path "$env:BUILD_DIR\CMakeFiles\CMakeOutput.log") {
            Get-Content "$env:BUILD_DIR\CMakeFiles\CMakeOutput.log" -TotalCount 200
          }

      - name: Show available MSBuild targets (debug)
        shell: pwsh
        run: |
          cmake --build $env:BUILD_DIR --config Release --target help | Select-String -Pattern "package-windows" -SimpleMatch -Quiet
          if ($LASTEXITCODE -eq 0) {
            Write-Host "package-windows target is present."
          } else {
            Write-Host "package-windows target not found. Listing all available targets:"
            cmake --build $env:BUILD_DIR --config Release --target help
          }

      - name: Build and Package (try package-windows, fallback to manual makensis)
        shell: pwsh
        env:
          MAKENSIS_FALLBACK: ${{ env.MAKENSIS_DEFAULT }}
        run: |
          # Tenta construir o target package-windows
          $helpOutput = cmake --build $env:BUILD_DIR --config Release --target help 2>&1
          if ($helpOutput -match "package-windows") {
            Write-Host "package-windows target exists — building it."
            cmake --build $env:BUILD_DIR --config Release --target package-windows --parallel
            if ($LASTEXITCODE -ne 0) { throw "CMake build for target package-windows failed." }
          } else {
            Write-Host "package-windows not present — fallback procedure:"
            Write-Host "1) build main project binaries"
            cmake --build $env:BUILD_DIR --config Release --parallel
            if ($LASTEXITCODE -ne 0) { throw "CMake build for default target failed." }

            Write-Host "2) Look for .nsi files to run makensis on"
            $nsiPaths = Get-ChildItem -Path . -Include *.nsi -Recurse -File -ErrorAction SilentlyContinue
            if ($nsiPaths.Count -eq 0) {
              throw "Fallback failed: no .nsi installer script found in the repository."
            }

            Write-Host "Found .nsi files:"
            $nsiPaths | ForEach-Object { Write-Host "- $($_.FullName)" }
            $nsiFile = $nsiPaths[0].FullName
            
            $makensis = (Get-Command makensis -ErrorAction SilentlyContinue).Source
            if (-not $makensis) { $makensis = $env:MAKENSIS_FALLBACK }
            Write-Host "Using makensis: $makensis"
            
            & $makensis "/V2" $nsiFile
            if ($LASTEXITCODE -ne 0) { throw "makensis failed with code $LASTEXITCODE" }
          }

      - name: Collect installer artifacts
        id: collect_installer
        shell: pwsh
        run: |
          $searchPaths = @("$env:BUILD_DIR", "$env:GITHUB_WORKSPACE", "$env:GITHUB_WORKSPACE/installer/windows")
          $installerCandidates = @()
          foreach ($p in $searchPaths) {
            if (Test-Path $p) {
              $installerCandidates += Get-ChildItem -Path $p -Include *.exe -Recurse -File -ErrorAction SilentlyContinue | Where-Object { $_.Name -match "installer" -or $_.Length -gt 1MB }
            }
          }

          if ($installerCandidates.Count -eq 0) {
            Write-Host "No installer .exe found automatically. Listing build tree for debugging:"
            Get-ChildItem -Path $env:BUILD_DIR -Recurse -File | Select-Object FullName, Length | Sort-Object Length -Descending | Select-Object -First 50
            throw "No installer .exe found to upload."
          }

          Write-Host "Found installer candidates:"
          $installerCandidates | ForEach-Object { Write-Host "- $($_.FullName)" }
          # Pega o maior arquivo .exe, que provavelmente é o instalador
          $installerPath = ($installerCandidates | Sort-Object Length -Descending | Select-Object -First 1).FullName
          
          Write-Host "Selected installer to upload: $installerPath"
          # Salva o caminho para o próximo passo usar
          echo "installer_path=$installerPath" >> $env:GITHUB_OUTPUT

      - name: Upload Installer Artifact
        uses: actions/upload-artifact@v4
        with:
          name: windows-installer
          path: ${{ steps.collect_installer.outputs.installer_path }}
          retention-days: 7

      - name: Final status (debug)
        if: always()
        shell: pwsh
        run: |
          Write-Host "Workflow finished. Check previous steps logs for errors."
