# .github/workflows/build-installer-windows.yml
name: Build and Package Windows Installer

on:
  push:
    branches: [ "main" ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

env:
  VCPKG_DEFAULT_TRIPLET: x64-windows
  VCPKG_INSTALL_LIST: "curl lua nlohmann-json"    # editar se quiser outros pacotes
  CMAKE_VERSION: "3.29.3"
  RUST_TOOLCHAIN: "stable"
  ARTIFACT_NAME: "windows-installer"

jobs:
  build:
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup CMake
        uses: jwlawson/actions-setup-cmake@v1
        with:
          cmake-version: ${{ env.CMAKE_VERSION }}

      - name: Install Ninja
        run: choco install ninja -y
        shell: pwsh

      - name: Create vcpkg folder env
        run: |
          echo "VCPKG_ROOT=${{ github.workspace }}\vcpkg" >> $GITHUB_ENV

      - name: Install vcpkg and libraries (robusto, sem telemetry)
        shell: pwsh
        env:
          VCPKG_ROOT: ${{ github.workspace }}\vcpkg
          VCPKG_DEFAULT_TRIPLET: ${{ env.VCPKG_DEFAULT_TRIPLET }}
          # desativa métricas por segurança/privacidade
          VCPKG_DISABLE_METRICS: "1"
        run: |
          $ErrorActionPreference = 'Stop'
          if (!(Test-Path -Path $env:VCPKG_ROOT)) {
            git clone https://github.com/microsoft/vcpkg.git $env:VCPKG_ROOT
          } else {
            Write-Host "vcpkg already cloned"
          }
          Push-Location $env:VCPKG_ROOT
          # bootstrap sem telemetry (documentado no vcpkg).
          .\bootstrap-vcpkg.bat -disableMetrics
          # instala pacotes (idempotente)
          .\vcpkg.exe install $env:VCPKG_INSTALL_LIST --triplet $env:VCPKG_DEFAULT_TRIPLET
          Pop-Location

      - name: Check if this repo has a Cargo.toml (sets step output)
        id: check_cargo
        shell: pwsh
        run: |
          if (Test-Path -Path "Cargo.toml") {
            echo "has_cargo=true" >> $GITHUB_OUTPUT
          } else {
            echo "has_cargo=false" >> $GITHUB_OUTPUT
          }

      - name: Setup Rust toolchain (only if repo has Rust)
        if: ${{ steps.check_cargo.outputs.has_cargo == 'true' }}
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: ${{ env.RUST_TOOLCHAIN }}

      - name: Install NSIS (makensis) and validate
        id: find_makensis
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          choco install nsis --yes --no-progress
          # buscar localização do makensis (padrão chocolatey cria link em ProgramData)
          try {
            $cmd = Get-Command makensis -ErrorAction Stop
            $path = $cmd.Path
            Write-Host "makensis found at: $path"
          } catch {
            # tentativa de fallback: olhar em ProgramData\chocolatey\bin
            $fallback = "C:\ProgramData\chocolatey\bin\makensis.exe"
            if (Test-Path -Path $fallback) { $path = $fallback; Write-Host "makensis fallback found at $fallback" }
            else {
              Write-Host "makensis not found; printing PATH for debug"
              $env:Path.Split(";") | ForEach-Object { Write-Host $_ }
              throw "makensis not found after choco install nsis"
            }
          }
          echo "makensis_path=$path" >> $GITHUB_OUTPUT
          # also expose the directory
          $dir = Split-Path -Path $path -Parent
          echo "makensis_dir=$dir" >> $GITHUB_OUTPUT

      - name: Configure CMake (MSVC, Visual Studio generator) - robust
        shell: pwsh
        env:
          VCPKG_ROOT: ${{ github.workspace }}\vcpkg
          MAKENSIS: ${{ steps.find_makensis.outputs.makensis_path }}
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "Using vcpkg at $env:VCPKG_ROOT"
          # extra logging para depuração
          & cmake --version
          Get-ChildItem -Path $env:VCPKG_ROOT -Force | Select-Object -First 5 | ForEach-Object { Write-Host $_.Name }
          # Passa MAKENSIS_EXECUTABLE explicitamente (alguns Find modules usam essa variável)
          cmake -S . -B build -G "Visual Studio 17 2022" -A x64 `
            -DCMAKE_TOOLCHAIN_FILE="${{ env.VCPKG_ROOT }}\scripts\buildsystems\vcpkg.cmake" `
            -DCMAKE_PREFIX_PATH="${{ env.VCPKG_ROOT }}\installed\x64-windows\share" `
            -DLua_FOUND=TRUE `
            -DLUA_INCLUDE_DIR="${{ env.VCPKG_ROOT }}\installed\x64-windows\include" `
            -DLUA_LIBRARIES="${{ env.VCPKG_ROOT }}\installed\x64-windows\lib\lua.lib" `
            -DCMAKE_BUILD_TYPE=Release `
            -DMAKENSIS_EXECUTABLE="${{ steps.find_makensis.outputs.makensis_path }}" `
            -DNSIS_DIR="${{ steps.find_makensis.outputs.makensis_dir }}"

      - name: Show generated CMake targets (debug)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          cmake --build build --target help | Out-String | Write-Host

      - name: Build and Package (tries package-windows; fallback to plan B)
        id: do_build
        shell: pwsh
        env:
          MAKENSIS: ${{ steps.find_makensis.outputs.makensis_path }}
        run: |
          $ErrorActionPreference = 'Stop'
          $buildDir = Join-Path $PWD "build"
          # 1) If Visual Studio target exists, build it
          $proj = Get-ChildItem -Path $buildDir -Recurse -Filter "package-windows.vcxproj" -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($proj) {
            Write-Host "Found package-windows project: $($proj.FullName)"
            cmake --build $buildDir --config Release --target package-windows --parallel
          } else {
            Write-Host "package-windows target not found. Listing cmake targets for diagnosis..."
            cmake --build $buildDir --target help
            # try to build an installer helper target if exists
            $alt = Get-ChildItem -Path $buildDir -Recurse -Include "*installer_helper*.vcxproj","*installer*.*proj" -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($alt) {
              Write-Host "Found alternative build project: $($alt.FullName) -- attempting to build it"
              # tenta extrair target name do filename
              $targetName = "ALL_BUILD"
              if ($alt.BaseName -match "installer_helper") { $targetName = "installer_helper" }
              cmake --build $buildDir --config Release --target $targetName --parallel
            } else {
              Write-Host "No explicit installer project found. Procurando arquivos .nsi gerados..."
              $nsi = Get-ChildItem -Path $buildDir -Recurse -Filter "*.nsi" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($nsi) {
                Write-Host "Found .nsi file at $($nsi.FullName) — compiling with makensis"
                & $env:MAKENSIS $nsi.FullName
              } else {
                Write-Host "Nenhum projeto de pacote ou .nsi encontrado. Saindo com erro para depuração."
                throw "package-windows não encontrado e não foi possível localizar alternativa."
              }
            }
          }

          # coletar possíveis artefatos .exe para upload
          $candidates = Get-ChildItem -Path $buildDir -Recurse -Include "*.exe" -ErrorAction SilentlyContinue | Where-Object { $_.Length -gt 0 } | Sort-Object LastWriteTime -Descending
          if ($candidates) {
            $top = $candidates | Select-Object -First 5
            Write-Host "Artifacts found:"
            $top | ForEach-Object { Write-Host $_.FullName }
            # grava lista para etapa de upload
            $list = ($top | ForEach-Object { $_.FullName }) -join "`n"
            echo "artifact_paths=$list" >> $GITHUB_OUTPUT
          } else {
            Write-Host "Nenhum executável encontrado no diretório build; talvez packaging gere outro formato."
            echo "artifact_paths=" >> $GITHUB_OUTPUT
          }

      - name: Upload Installer Artifact (best-effort)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: |
            ${{ fromJson('["' + join('","', steps.do_build.outputs.artifact_paths ? steps.do_build.outputs.artifact_paths.split(`n`) : []) + '"]') }}
            build/*.exe
          retention-days: 7
