#
# release.yml - Publishes a GitHub Release with build artifacts.
#
# This workflow is triggered ONLY upon the successful completion of one of the main
# build workflows. It then performs several critical checks and actions:
#
# 1. It verifies that the completed build workflow was triggered by a tag (e.g., 'v1.2.3').
# 2. It downloads all the release packages (.tar.gz, .zip) created by the various build jobs.
# 3. It automatically creates a new GitHub Release corresponding to the tag.
# 4. It uploads all the downloaded packages as assets to that new release.
#
# This separation of concerns ensures that releases are only published if all builds
# are successful and correctly prepared.
#

name: Publish GitHub Release

#
# This workflow is triggered by the completion of another workflow.
# We only need to watch one of the build workflows (e.g., the Ubuntu one)
# because they are all triggered by the same event (a tag push).
#
on:
  workflow_run:
    workflows: ["Build gitph (Ubuntu/Debian-like Systems)"]
    types:
      - completed

jobs:
  publish:
    name: Publish Release
    # This job runs only if the triggering workflow was successful AND it was for a tag.
    # The `head_branch` in the workflow_run context contains the full ref, e.g., 'refs/tags/v1.0.0'.
    if: github.event.workflow_run.conclusion == 'success' && startsWith(github.event.workflow_run.head_branch, 'refs/tags/v')
    runs-on: ubuntu-latest

    #
    # Permissions are crucial. This job needs permission to write to 'contents'
    # to be able to create a release and upload assets to it.
    #
    permissions:
      contents: write

    steps:
      # Step 1: Download all the release package artifacts from the completed workflow run.
      # The `github-actions` user automatically creates a special artifact containing all artifacts
      # from a workflow run, which makes downloading them much easier.
      # We will download them into a directory named 'release-artifacts'.
      - name: Download all release artifacts
        uses: actions/download-artifact@v4
        with:
          # The run-id of the completed workflow that triggered this one.
          run-id: ${{ github.event.workflow_run.id }}
          # The directory where all artifacts will be placed.
          path: release-artifacts

      # Step 2: Extract the tag name from the Git ref.
      # The ref is in the format 'refs/tags/v1.2.3'. This step strips the 'refs/tags/' prefix.
      - name: Get tag name
        id: get_tag
        run: echo "tag_name=$(echo ${{ github.event.workflow_run.head_branch }} | sed 's/refs\/tags\///')" >> $GITHUB_OUTPUT

      # Step 3: Create the GitHub Release.
      # This uses the tag name from the previous step and automatically generates release notes
      # based on the commits between this tag and the previous one.
      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.get_tag.outputs.tag_name }}
          release_name: "Release ${{ steps.get_tag.outputs.tag_name }}"
          # Set to true to automatically create release notes from commits.
          generate_release_notes: true
          # Set to false for a final release. Use true if you want to review it first.
          draft: false
          prerelease: false

      # Step 4: Upload all downloaded artifacts to the new release.
      # This step iterates through all files in the 'release-artifacts' directory
      # (which contains subdirectories for each artifact) and uploads them.
      - name: Upload Release Assets
        run: |
          # Find all package files (.tar.gz and .zip) within the downloaded artifacts directory.
          # The `find` command handles the nested directory structure created by download-artifact.
          find release-artifacts -type f \( -name "*.tar.gz" -o -name "*.zip" \) | while read -r asset_path; do
            asset_name=$(basename "$asset_path")
            echo "Uploading $asset_name from $asset_path..."
            gh release upload "${{ steps.get_tag.outputs.tag_name }}" "$asset_path" --clobber
          done
        env:
          # The GitHub CLI (gh) is pre-installed on runners and uses this token for authentication.
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
