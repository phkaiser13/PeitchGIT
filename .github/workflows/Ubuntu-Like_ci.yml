# Copyright (C) 2025 Pedro Henrique / phkaiser13
# Ubuntu-Like_ci.yml - Workflow de Integração Contínua para o projeto gitph.
#
# Este workflow automatiza o processo de build e release da aplicação em múltiplas
# arquiteturas para sistemas baseados em Debian/Ubuntu.
#
# SPDX-License-Identifier: Apache-2.0

name: Build e Release Multi-Arquitetura Ubuntu-like (Linux)

on:
  push:
    branches: [ "main" ]
    tags:
      - 'v*'
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    name: Build em ${{ matrix.name }}
    runs-on: ubuntu-latest
    
    # A matriz define as diferentes configurações para cada arquitetura
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: "Ubuntu (x86_64)"
            arch: "amd64"
            platform: "x86_64-linux-gnu"
          - name: "Ubuntu (aarch64)"
            arch: "arm64"
            platform: "aarch64-linux-gnu"
          - name: "Ubuntu (i386)"
            arch: "i386"
            platform: "i686-linux-gnu" # O nome da toolchain para i386 pode ser i686

    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      # Configura o QEMU para permitir a execução de binários de outras arquiteturas
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      # Instala as dependências de sistema para a arquitetura alvo
      - name: Instalar dependências de cross-compilação
        run: |
          sudo apt-get update
          # Adiciona a arquitetura estrangeira ao dpkg
          sudo dpkg --add-architecture ${{ matrix.arch }}
          # Instala as ferramentas de compilação base e as de cross-compilação
          sudo apt-get install -y build-essential cmake pkg-config gcc-${{ matrix.platform }} g++-${{ matrix.platform }}
          # Instala as bibliotecas para a arquitetura alvo
          sudo apt-get install -y liblua5.4-dev:${{ matrix.arch }} libcurl4-openssl-dev:${{ matrix.arch }} nlohmann-json3-dev

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
          # Adiciona o target para cross-compilação do Rust
          targets: ${{ matrix.platform }}
      - uses: Swatinem/rust-cache@v2

      # Cria um arquivo de toolchain para o CMake para forçar a cross-compilação
      - name: Criar arquivo de Toolchain do CMake
        run: |
          echo "set(CMAKE_SYSTEM_NAME Linux)" > toolchain.cmake
          echo "set(CMAKE_SYSTEM_PROCESSOR ${{ matrix.arch }})" >> toolchain.cmake
          echo "set(CMAKE_C_COMPILER ${{ matrix.platform }}-gcc)" >> toolchain.cmake
          echo "set(CMAKE_CXX_COMPILER ${{ matrix.platform }}-g++)" >> toolchain.cmake
          echo "set(CMAKE_FIND_ROOT_PATH /usr/${{ matrix.platform }})" >> toolchain.cmake
          echo "set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)" >> toolchain.cmake
          echo "set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)" >> toolchain.cmake
          echo "set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)" >> toolchain.cmake

      - name: Configurar CMake com Toolchain
        run: cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake

      - name: Compilar Projeto
        run: cmake --build build --parallel

      - name: Preparar artefatos para upload
        shell: bash
        run: |
          ARTIFACT_DIR="artifacts"
          mkdir -p "$ARTIFACT_DIR/modules"
          cp build/bin/* "$ARTIFACT_DIR/"
          cp -r src/plugins/* "$ARTIFACT_DIR/modules/"
          cp LICENSE "$ARTIFACT_DIR/"

      - name: Upload dos artefatos de build
        uses: actions/upload-artifact@v4
        with:
          name: gitph-build-artifacts-linux-${{ matrix.arch }}
          path: artifacts/

  release:
    name: Criar Release
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
      - name: Download de todos os artefatos de build
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
      
      - name: Empacotar para Release
        run: |
          # Loop através de cada diretório de artefato baixado
          for DIR in artifacts/gitph-build-artifacts-linux-*; do
            ARCH=$(basename "$DIR" | sed 's/gitph-build-artifacts-linux-//')
            VERSION="${{ github.ref_name }}"
            RELEASE_NAME="gitph-${VERSION}-linux-${ARCH}"
            
            echo "Empacotando $RELEASE_NAME..."
            
            # Cria a estrutura de diretório final
            mkdir -p "release/${RELEASE_NAME}"
            mv "${DIR}"/* "release/${RELEASE_NAME}/"
            
            # Remove símbolos de debug
            echo "Removendo símbolos de debug para ${ARCH}..."
            strip --strip-unneeded "release/${RELEASE_NAME}/gitph"
            find "release/${RELEASE_NAME}/modules" -type f -name "*.so" -exec strip --strip-unneeded {} +
            
            # Cria o arquivo .tar.gz
            (cd release && tar -czf "${RELEASE_NAME}.tar.gz" "${RELEASE_NAME}")
          done
          
          # Exporta a lista de pacotes para o próximo passo
          echo "RELEASE_ASSETS=$(ls release/*.tar.gz | tr '\n' ' ')" >> $GITHUB_ENV

      - name: Publicar Release no GitHub
        uses: softprops/action-gh-release@v2
        with:
          # Anexa todos os pacotes .tar.gz criados
          files: ${{ env.RELEASE_ASSETS }}
          generate_release_notes: true
