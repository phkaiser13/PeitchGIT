# Copyright (C) 2025 Pedro Henrique / phkaiser13
# Ubuntu-Like_ci.yml - Workflow de Integração Contínua para o projeto gitph.
#
# Este workflow automatiza o processo de build e release da aplicação.
# Ele é configurado para compilar e empacotar a aplicação para múltiplas
# arquiteturas em sistemas Debian/Ubuntu e derivados (Ubuntu-like).
# Arquiteturas suportadas: x86_64 (amd64), aarch64 (arm64), e i386.
#
# SPDX-License-Identifier: Apache-2.0

name: Build e Release Multi-Arch do gitph

# Gatilhos do workflow:
on:
  push:
    branches: [ "main" ]
    tags:
      - 'v*'
  pull_request:
    branches: [ "main" ]

jobs:
  # Job de build que agora usa uma matriz para compilar para várias arquiteturas
  build:
    # O nome do job agora é dinâmico para refletir a arquitetura
    name: Build para ${{ matrix.name }}
    # Usamos sempre o runner x86_64 e emulamos as outras arquiteturas com QEMU
    runs-on: ubuntu-latest

    # ESTRATÉGIA: Define a matriz de build para diferentes arquiteturas
    strategy:
      fail-fast: false # Garante que todos os jobs da matriz rodem, mesmo que um falhe
      matrix:
        include:
          - name: 'Debian/Ubuntu (x86_64)'
            arch: 'x86_64'
            deb_arch: 'amd64'
          - name: 'Debian/Ubuntu (aarch64)'
            arch: 'aarch64'
            deb_arch: 'arm64'
          - name: 'Debian/Ubuntu (i386)'
            arch: 'i686' # 'uname -m' para 32-bit costuma ser i686
            deb_arch: 'i386'

    steps:
      # 1. Clona o repositório
      - name: Checkout do código
        uses: actions/checkout@v4

      # 2. Configura o QEMU para permitir a emulação de outras arquiteturas
      #    Essencial para compilar para ARM e i386 em um runner x86_64
      - name: Setup QEMU
        uses: docker/setup-qemu-action@v3

      # 3. Instala as dependências de sistema para cross-compilation
      - name: Instalar dependências de cross-compilation
        run: |
          # Adiciona a arquitetura de destino ao dpkg (se não for a nativa)
          if [ "${{ matrix.deb_arch }}" != "amd64" ]; then
            sudo dpkg --add-architecture ${{ matrix.deb_arch }}
          fi
          sudo apt-get update
          # Instala as ferramentas de build (nativas) e as bibliotecas (para a arquitetura de destino)
          sudo apt-get install -y build-essential cmake pkg-config \
            liblua5.4-dev:${{ matrix.deb_arch }} \
            libcurl4-openssl-dev:${{ matrix.deb_arch }} \
            nlohmann-json3-dev

      # 4. Configura o ambiente Go
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      # 5. Configura o ambiente Rust (com cache)
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
          # Adiciona o alvo de compilação para Rust (se for cross-compiling)
          targets: ${{ matrix.arch }}-unknown-linux-gnu
      - uses: Swatinem/rust-cache@v2

      # 6. Configura e compila o projeto usando CMake
      #    Para cross-compilation, precisamos informar ao CMake qual toolchain usar.
      - name: Configurar CMake
        run: |
          # Para cross-compiling, definimos o toolchain file do CMake
          if [ "${{ matrix.deb_arch }}" != "amd64" ]; then
            TOOLCHAIN_FLAGS="-DCMAKE_TOOLCHAIN_FILE=../cmake/cross-${{ matrix.arch }}.cmake"
          fi
          cmake -S . -B build -DCMAKE_BUILD_TYPE=Release $TOOLCHAIN_FLAGS

      - name: Compilar Projeto
        run: cmake --build build --parallel

      # 7. Salva os artefatos de build, nomeando-os com a arquitetura
      - name: Upload dos artefatos de build
        uses: actions/upload-artifact@v4
        with:
          # O nome do artefato inclui a arquitetura para ser único
          name: gitph-build-artifacts-${{ matrix.arch }}
          path: |
            build/bin/
            src/plugins/
            LICENSE

  # Job de release que coleta todos os artefatos e cria os pacotes
  release:
    name: Criar Release Multi-Arch
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
      # 1. Clona o repositório
      - name: Checkout do código
        uses: actions/checkout@v4

      # 2. Baixa TODOS os artefatos de build de todas as arquiteturas
      - name: Download de todos os artefatos de build
        uses: actions/download-artifact@v4
        with:
          # O path onde os artefatos (cada um em sua pasta) serão salvos
          path: artifacts/

      # 3. Instala ferramentas para 'strip' de diferentes arquiteturas
      - name: Instalar binutils para cross-stripping
        run: sudo apt-get update && sudo apt-get install -y binutils-aarch64-linux-gnu binutils-i686-linux-gnu

      # 4. Empacota os arquivos para cada arquitetura
      - name: Empacotar para Release
        run: |
          set -e # Aborta o script se qualquer comando falhar
          VERSION=${{ github.ref_name }}
          mkdir -p release # Pasta final para os pacotes .tar.gz

          # Itera sobre cada pasta de artefato baixada (ex: artifacts/gitph-build-artifacts-x86_64)
          for ARTIFACT_DIR in artifacts/gitph-build-artifacts-*/; do
            # Extrai a arquitetura do nome da pasta
            ARCH=$(basename "$ARTIFACT_DIR" | sed 's/gitph-build-artifacts-//')
            echo "--- Empacotando para arquitetura: ${ARCH} ---"

            RELEASE_NAME="gitph-${VERSION}-linux-${ARCH}"
            PACKAGE_DIR="release/${RELEASE_NAME}"
            
            # Cria a estrutura de diretórios final
            mkdir -p "${PACKAGE_DIR}/modules"
            
            # Copia os arquivos do artefato para a estrutura final
            cp -r "${ARTIFACT_DIR}"/bin/* "${PACKAGE_DIR}/"
            cp -r "${ARTIFACT_DIR}"/plugins/* "${PACKAGE_DIR}/modules/"
            cp "${ARTIFACT_DIR}"/LICENSE "${PACKAGE_DIR}/"
            
            # Define o comando 'strip' correto para a arquitetura
            STRIP_COMMAND="strip"
            if [ "$ARCH" == "aarch64" ]; then
              STRIP_COMMAND="aarch64-linux-gnu-strip"
            elif [ "$ARCH" == "i686" ]; then
              STRIP_COMMAND="i686-linux-gnu-strip"
            fi
            
            # Remove símbolos de debug dos binários para reduzir o tamanho
            echo "Removendo símbolos de debug com '$STRIP_COMMAND'..."
            $STRIP_COMMAND --strip-unneeded "${PACKAGE_DIR}/gitph"
            find "${PACKAGE_DIR}/modules" -type f -name "*.so" -exec $STRIP_COMMAND --strip-unneeded {} +
            
            # Cria o arquivo .tar.gz final
            echo "Criando o pacote ${RELEASE_NAME}.tar.gz..."
            (cd release && tar -czf "${RELEASE_NAME}.tar.gz" "${RELEASE_NAME}")
          done
          
          # Exporta o caminho dos pacotes para o próximo passo
          echo "RELEASE_PATHS=release/*.tar.gz" >> $GITHUB_ENV

      # 5. Cria a Release no GitHub e faz o upload de TODOS os pacotes .tar.gz
      - name: Publicar Release no GitHub
        uses: softprops/action-gh-release@v2
        with:
          # Usa um glob pattern para encontrar e fazer upload de todos os pacotes
          files: ${{ env.RELEASE_PATHS }}
          generate_release_notes: true
