# .github/workflows/windows_ci.yml
# Copyright (C) 2025 Pedro Henrique / phkaiser13
# Workflow de Integração Contínua para Windows usando vcpkg e CMake.
# Versão melhorada: clonagem manual do vcpkg (mais previsível), suporte a arquitetura x64,
# paths/checagens robustas para empacotar artifacts e mensagens mais claras.
# SPDX-License-Identifier: Apache-2.0

name: Build e Release do gitph (Windows)

on:
  push:
    branches: [ "main" ]
    tags:
      - 'v*'
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    name: Build e Teste (Windows)
    runs-on: windows-latest
    env:
      # padrão de arquitetura usada no workflow
      ARCH: x64

    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Setup Rust (stable)
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          components: rustfmt,clippy

      - name: Instalar vcpkg (clone + bootstrap + instalar pacotes)
        shell: pwsh
        run: |
          # cria pasta vcpkg no workspace
          $vcpkgDir = Join-Path $env:GITHUB_WORKSPACE 'vcpkg'
          if (-Not (Test-Path $vcpkgDir)) {
            git clone --depth=1 https://github.com/microsoft/vcpkg.git $vcpkgDir
          }
          Push-Location $vcpkgDir
          # bootstrap (gera vcpkg.exe)
          .\bootstrap-vcpkg.bat
          # instale os pacotes necessários (x64)
          .\vcpkg.exe install curl:x64-windows lua:x64-windows nlohmann-json:x64-windows
          Pop-Location
          # exporta VCPKG_ROOT para os passos seguintes
          "VCPKG_ROOT=$vcpkgDir" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Configurar CMake (gerar build files)
        shell: pwsh
        env:
          VCPKG_ROOT: ${{ env.VCPKG_ROOT }}
        run: |
          if (-Not (Test-Path "$env:GITHUB_WORKSPACE/build")) { New-Item -ItemType Directory -Path "$env:GITHUB_WORKSPACE/build" | Out-Null }
          cmake -S . -B build -A $env:ARCH -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE="$env:VCPKG_ROOT\scripts\buildsystems\vcpkg.cmake"

      - name: Compilar Projeto
        shell: pwsh
        run: |
          cmake --build build --config Release --parallel

      - name: Listar binários gerados (debug)
        shell: pwsh
        run: |
          Write-Host "*** Conteúdo de build (recursivo) ***"
          Get-ChildItem -Path build -Recurse -Force | Where-Object { $_.PSIsContainer -eq $false } | Select-Object FullName | ForEach-Object { Write-Host $_.FullName }

      - name: Upload dos artefatos de build (Windows)
        uses: actions/upload-artifact@v4
        with:
          name: gitph-build-artifacts-windows
          path: |
            build\**\Release\*.exe
            build\**\Release\*.dll
            build\**\*.pdb
            build\**\modules\**\Release\*
            src\plugins\**
            LICENSE

  release:
    name: Criar Release (Windows)
    needs: build
    runs-on: windows-latest
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      - name: Download dos artefatos de build
        uses: actions/download-artifact@v4
        with:
          name: gitph-build-artifacts-windows
          path: artifacts/

      - name: Empacotar para Release (Windows)
        shell: pwsh
        run: |
          $VERSION = "${{ github.ref_name }}"
          $RELEASE_NAME = "gitph-$VERSION-windows-x64"
          $RELEASE_PATH = "release/$RELEASE_NAME"

          if (-Not (Test-Path $RELEASE_PATH)) { New-Item -ItemType Directory -Path $RELEASE_PATH -Force | Out-Null }
          if (-Not (Test-Path "$RELEASE_PATH/modules")) { New-Item -ItemType Directory -Path "$RELEASE_PATH/modules" -Force | Out-Null }
          if (-Not (Test-Path "$RELEASE_PATH/plugins")) { New-Item -ItemType Directory -Path "$RELEASE_PATH/plugins" -Force | Out-Null }

          # Copia arquivos com checagens
          Get-ChildItem -Path "artifacts" -Recurse -File | ForEach-Object {
            $dest = Join-Path $RELEASE_PATH $_.Name
            Copy-Item -Path $_.FullName -Destination $dest -Force
          }

          # Tenta copiar pasta modules/plugins se existirem
          if (Test-Path "artifacts/modules") { Copy-Item -Path "artifacts/modules/*" -Destination "$RELEASE_PATH/modules/" -Recurse -Force }
          if (Test-Path "artifacts/plugins") { Copy-Item -Path "artifacts/plugins/*" -Destination "$RELEASE_PATH/plugins/" -Recurse -Force }
          if (Test-Path "artifacts/LICENSE") { Copy-Item -Path "artifacts/LICENSE" -Destination "$RELEASE_PATH/" -Force }

          # Cria o ZIP final
          $zipPath = "release/$RELEASE_NAME.zip"
          if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
          Compress-Archive -Path "$RELEASE_PATH/*" -DestinationPath $zipPath -Force

          echo "RELEASE_ZIP_PATH=$zipPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Publicar Release no GitHub
        uses: softprops/action-gh-release@v2
        with:
          files: ${{ env.RELEASE_ZIP_PATH }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
