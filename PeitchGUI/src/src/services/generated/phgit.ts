// src/services/generated/phgit.ts (Mock)
// This is a mock of the code generated by Protobuf.js or a similar tool.
// It provides the necessary structure and methods for the peitchGitService to function.

const mockEncode = (obj: any): Uint8Array => new TextEncoder().encode(JSON.stringify(obj));
const mockDecode = (arr: Uint8Array, defaultObj: any): any => {
    const str = new TextDecoder().decode(arr);
    try {
        return str ? JSON.parse(str) : defaultObj;
    } catch(e) {
        return defaultObj;
    }
};
const mockFromObject = (obj: any): any => obj;

export namespace phgit {
    // --- Request Structures ---
    export class RepoRequest {
        repoPath: string;
        static create(properties: { repoPath: string }): RepoRequest { return properties as RepoRequest; }
        static encode(message: RepoRequest): { finish: () => Uint8Array } { return { finish: () => mockEncode(message) }; }
        static fromObject = mockFromObject;
    }

    export class CommitRequest {
        repoPath: string;
        message: string;
        authorName: string;
        authorEmail: string;
        static create(properties: any): CommitRequest { return properties; }
        static encode(message: CommitRequest): { finish: () => Uint8Array } { return { finish: () => mockEncode(message) }; }
        static fromObject = mockFromObject;
    }

    export class BranchRequest {
        repoPath: string;
        branchName: string;
        baseSha: string;
        static create(properties: any): BranchRequest { return properties; }
        static encode(message: BranchRequest): { finish: () => Uint8Array } { return { finish: () => mockEncode(message) }; }
        static fromObject = mockFromObject;
    }

    export class FileRequest {
        repoPath: string;
        filePath: string;
        static create(properties: any): FileRequest { return properties; }
        static encode(message: FileRequest): { finish: () => Uint8Array } { return { finish: () => mockEncode(message) }; }
        static fromObject = mockFromObject;
    }

    export class TagRequest {
        repoPath: string;
        tagName: string;
        sha: string;
        static create(properties: any): TagRequest { return properties; }
        static encode(message: TagRequest): { finish: () => Uint8Array } { return { finish: () => mockEncode(message) }; }
        static fromObject = mockFromObject;
    }

    export class CherryPickRequest {
        repoPath: string;
        sha: string;
        static create(properties: any): CherryPickRequest { return properties; }
        static encode(message: CherryPickRequest): { finish: () => Uint8Array } { return { finish: () => mockEncode(message) }; }
        static fromObject = mockFromObject;
    }
    
    export class HookRequest {
        repoPath: string;
        hookType: string;
        content: string;
        static create(properties: any): HookRequest { return properties; }
        static encode(message: HookRequest): { finish: () => Uint8Array } { return { finish: () => mockEncode(message) }; }
        static fromObject = mockFromObject;
    }

    // --- Response Structures ---
    export interface Author { name: string; email: string; }
    export interface Commit {
        sha: string;
        shortSha: string;
        message: string;
        author: Author | null;
        dateTimestamp: number;
        parents: string[];
        branch: string;
    }
    export interface Branch { name: string; isRemote: boolean; sha: string; }
    export interface WorkspaceFileChange { path: string; status: string; diff: string; }

    export class LoadRepositoryResponse {
        commits: Commit[];
        branches: Branch[];
        static decode(reader: Uint8Array | any): LoadRepositoryResponse { return mockDecode(reader, { commits: [], branches: [] }); }
        static fromObject = mockFromObject;
    }
    
    export class WorkspaceStatusResponse {
        stagedFiles: WorkspaceFileChange[];
        unstagedFiles: WorkspaceFileChange[];
        static decode(reader: Uint8Array | any): WorkspaceStatusResponse { return mockDecode(reader, { stagedFiles: [], unstagedFiles: [] }); }
        static fromObject = mockFromObject;
    }
}
